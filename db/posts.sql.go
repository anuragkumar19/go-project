// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: posts.sql

package database

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :many
INSERT INTO posts (
    title, text, image, video, link, subreddit_id, creator_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id
`

type CreatePostParams struct {
	Title       string `json:"title"`
	Text        string `json:"text"`
	Image       string `json:"image"`
	Video       string `json:"video"`
	Link        string `json:"link"`
	SubredditID int32  `json:"subreddit_id"`
	CreatorID   int32  `json:"creator_id"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, createPost,
		arg.Title,
		arg.Text,
		arg.Image,
		arg.Video,
		arg.Link,
		arg.SubredditID,
		arg.CreatorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts WHERE id = $1
`

func (q *Queries) DeletePost(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const findPostById = `-- name: FindPostById :many
SELECT id, creator_id, subreddit_id FROM posts
WHERE id = $1
`

type FindPostByIdRow struct {
	ID          int32 `json:"id"`
	CreatorID   int32 `json:"creator_id"`
	SubredditID int32 `json:"subreddit_id"`
}

func (q *Queries) FindPostById(ctx context.Context, id int32) ([]FindPostByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, findPostById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindPostByIdRow
	for rows.Next() {
		var i FindPostByIdRow
		if err := rows.Scan(&i.ID, &i.CreatorID, &i.SubredditID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeedPosts = `-- name: GetFeedPosts :many
SELECT
    posts.id,
    posts.title,
    posts.text,
    posts.image,
    posts.video,
    posts.link,
    posts.subreddit_id,
    posts.creator_id,
    posts.created_at,
    users.username AS creator_username,
    users.avatar AS creator_avatar,
    users.name AS creator_name,
    subreddit.name AS subreddit_name,
    subreddit.avatar AS subreddit_avatar,
    subreddit.is_verified AS subreddit_is_verified,
    subreddit.title AS subreddit_title,
    COALESCE(replies.replies_count, 0) AS replies_count,
    COALESCE(up_votes.up_vote_count, 0) AS up_vote_count,
    COALESCE(down_votes.down_vote_count, 0) AS down_vote_count,
    COALESCE(user_votes.vote, 0) AS vote
FROM
    posts
JOIN
    users ON posts.creator_id = users.id
JOIN
    subreddit ON posts.subreddit_id = subreddit.id
LEFT JOIN (
    SELECT post_id, COUNT(id) AS replies_count
    FROM replies
    GROUP BY post_id
) AS replies ON posts.id = replies.post_id
LEFT JOIN (
    SELECT post_id, COUNT(user_id) AS up_vote_count
    FROM vote_post
    WHERE down = FALSE
    GROUP BY post_id
) AS up_votes ON posts.id = up_votes.post_id
LEFT JOIN (
    SELECT post_id, COUNT(user_id) AS down_vote_count
    FROM vote_post
    WHERE down = TRUE
    GROUP BY post_id
) AS down_votes ON posts.id = down_votes.post_id
LEFT JOIN (
    SELECT post_id, MAX(CASE WHEN vp.user_id = $4 AND vp.down = FALSE THEN 1 WHEN vp.user_id = $4 AND vp.down = TRUE THEN -1 ELSE 0 END) AS vote
    FROM vote_post AS vp
    WHERE vp.user_id = $4
    GROUP BY vp.post_id
) AS user_votes ON posts.id = user_votes.post_id
WHERE
    posts.subreddit_id = ANY($1::int[])
ORDER BY
    posts.created_at DESC
LIMIT
    $2
OFFSET
    $3
`

type GetFeedPostsParams struct {
	Column1 []int32 `json:"column_1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
	UserID  int32   `json:"user_id"`
}

type GetFeedPostsRow struct {
	ID                  int32       `json:"id"`
	Title               string      `json:"title"`
	Text                string      `json:"text"`
	Image               string      `json:"image"`
	Video               string      `json:"video"`
	Link                string      `json:"link"`
	SubredditID         int32       `json:"subreddit_id"`
	CreatorID           int32       `json:"creator_id"`
	CreatedAt           time.Time   `json:"created_at"`
	CreatorUsername     string      `json:"creator_username"`
	CreatorAvatar       string      `json:"creator_avatar"`
	CreatorName         string      `json:"creator_name"`
	SubredditName       string      `json:"subreddit_name"`
	SubredditAvatar     string      `json:"subreddit_avatar"`
	SubredditIsVerified bool        `json:"subreddit_is_verified"`
	SubredditTitle      string      `json:"subreddit_title"`
	RepliesCount        int64       `json:"replies_count"`
	UpVoteCount         int64       `json:"up_vote_count"`
	DownVoteCount       int64       `json:"down_vote_count"`
	Vote                interface{} `json:"vote"`
}

func (q *Queries) GetFeedPosts(ctx context.Context, arg GetFeedPostsParams) ([]GetFeedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFeedPosts,
		pq.Array(arg.Column1),
		arg.Limit,
		arg.Offset,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeedPostsRow
	for rows.Next() {
		var i GetFeedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Text,
			&i.Image,
			&i.Video,
			&i.Link,
			&i.SubredditID,
			&i.CreatorID,
			&i.CreatedAt,
			&i.CreatorUsername,
			&i.CreatorAvatar,
			&i.CreatorName,
			&i.SubredditName,
			&i.SubredditAvatar,
			&i.SubredditIsVerified,
			&i.SubredditTitle,
			&i.RepliesCount,
			&i.UpVoteCount,
			&i.DownVoteCount,
			&i.Vote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByIDPublic = `-- name: GetPostByIDPublic :many
SELECT
    posts.id,
    posts.title,
    posts.text,
    posts.image,
    posts.video,
    posts.link,
    posts.subreddit_id,
    posts.creator_id,
    posts.created_at,
    users.username AS creator_username,
    users.avatar AS creator_avatar,
    users.name AS creator_name,
    subreddit.name AS subreddit_name,
    subreddit.avatar AS subreddit_avatar,
    subreddit.is_verified AS subreddit_is_verified,
    subreddit.title AS subreddit_title,
    COALESCE(replies.replies_count, 0) AS replies_count,
    COALESCE(up_votes.up_vote_count, 0) AS up_vote_count,
    COALESCE(down_votes.down_vote_count, 0) AS down_vote_count,
    COALESCE(user_votes.vote, 0) AS vote
FROM
    posts
JOIN
    users ON posts.creator_id = users.id
JOIN
    subreddit ON posts.subreddit_id = subreddit.id
LEFT JOIN (
    SELECT post_id, COUNT(id) AS replies_count
    FROM replies
    GROUP BY post_id
) AS replies ON posts.id = replies.post_id
LEFT JOIN (
    SELECT post_id, COUNT(user_id) AS up_vote_count
    FROM vote_post
    WHERE down = FALSE
    GROUP BY post_id
) AS up_votes ON posts.id = up_votes.post_id
LEFT JOIN (
    SELECT post_id, COUNT(user_id) AS down_vote_count
    FROM vote_post
    WHERE down = TRUE
    GROUP BY post_id
) AS down_votes ON posts.id = down_votes.post_id
LEFT JOIN (
    SELECT post_id, MAX(CASE WHEN vp.user_id = $2 AND vp.down = FALSE THEN 1 WHEN vp.user_id = $2 AND vp.down = TRUE THEN -1 ELSE 0 END) AS vote
    FROM vote_post AS vp
    WHERE vp.user_id = $2
    GROUP BY vp.post_id
) AS user_votes ON posts.id = user_votes.post_id
WHERE
    posts.id = $1
`

type GetPostByIDPublicParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

type GetPostByIDPublicRow struct {
	ID                  int32       `json:"id"`
	Title               string      `json:"title"`
	Text                string      `json:"text"`
	Image               string      `json:"image"`
	Video               string      `json:"video"`
	Link                string      `json:"link"`
	SubredditID         int32       `json:"subreddit_id"`
	CreatorID           int32       `json:"creator_id"`
	CreatedAt           time.Time   `json:"created_at"`
	CreatorUsername     string      `json:"creator_username"`
	CreatorAvatar       string      `json:"creator_avatar"`
	CreatorName         string      `json:"creator_name"`
	SubredditName       string      `json:"subreddit_name"`
	SubredditAvatar     string      `json:"subreddit_avatar"`
	SubredditIsVerified bool        `json:"subreddit_is_verified"`
	SubredditTitle      string      `json:"subreddit_title"`
	RepliesCount        int64       `json:"replies_count"`
	UpVoteCount         int64       `json:"up_vote_count"`
	DownVoteCount       int64       `json:"down_vote_count"`
	Vote                interface{} `json:"vote"`
}

func (q *Queries) GetPostByIDPublic(ctx context.Context, arg GetPostByIDPublicParams) ([]GetPostByIDPublicRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostByIDPublic, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostByIDPublicRow
	for rows.Next() {
		var i GetPostByIDPublicRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Text,
			&i.Image,
			&i.Video,
			&i.Link,
			&i.SubredditID,
			&i.CreatorID,
			&i.CreatedAt,
			&i.CreatorUsername,
			&i.CreatorAvatar,
			&i.CreatorName,
			&i.SubredditName,
			&i.SubredditAvatar,
			&i.SubredditIsVerified,
			&i.SubredditTitle,
			&i.RepliesCount,
			&i.UpVoteCount,
			&i.DownVoteCount,
			&i.Vote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostVote = `-- name: GetPostVote :many
SELECT post_id, user_id, down FROM vote_post
WHERE post_id = $1 AND user_id = $2
`

type GetPostVoteParams struct {
	PostID int32 `json:"post_id"`
	UserID int32 `json:"user_id"`
}

type GetPostVoteRow struct {
	PostID int32 `json:"post_id"`
	UserID int32 `json:"user_id"`
	Down   bool  `json:"down"`
}

func (q *Queries) GetPostVote(ctx context.Context, arg GetPostVoteParams) ([]GetPostVoteRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostVote, arg.PostID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostVoteRow
	for rows.Next() {
		var i GetPostVoteRow
		if err := rows.Scan(&i.PostID, &i.UserID, &i.Down); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfUser = `-- name: GetPostsOfUser :many
SELECT
    posts.id,
    posts.title,
    posts.text,
    posts.image,
    posts.video,
    posts.link,
    posts.subreddit_id,
    posts.creator_id,
    posts.created_at,
    users.username AS creator_username,
    users.avatar AS creator_avatar,
    users.name AS creator_name,
    subreddit.name AS subreddit_name,
    subreddit.avatar AS subreddit_avatar,
    subreddit.is_verified AS subreddit_is_verified,
    subreddit.title AS subreddit_title,
    COALESCE(replies.replies_count, 0) AS replies_count,
    COALESCE(up_votes.up_vote_count, 0) AS up_vote_count,
    COALESCE(down_votes.down_vote_count, 0) AS down_vote_count,
    COALESCE(user_votes.vote, 0) AS vote
FROM
    posts
JOIN
    users ON posts.creator_id = users.id
JOIN
    subreddit ON posts.subreddit_id = subreddit.id
LEFT JOIN (
    SELECT post_id, COUNT(id) AS replies_count
    FROM replies
    GROUP BY post_id
) AS replies ON posts.id = replies.post_id
LEFT JOIN (
    SELECT post_id, COUNT(user_id) AS up_vote_count
    FROM vote_post
    WHERE down = FALSE
    GROUP BY post_id
) AS up_votes ON posts.id = up_votes.post_id
LEFT JOIN (
    SELECT post_id, COUNT(user_id) AS down_vote_count
    FROM vote_post
    WHERE down = TRUE
    GROUP BY post_id
) AS down_votes ON posts.id = down_votes.post_id
LEFT JOIN (
    SELECT post_id, MAX(CASE WHEN vp.user_id = $4 AND vp.down = FALSE THEN 1 WHEN vp.user_id = $4 AND vp.down = TRUE THEN -1 ELSE 0 END) AS vote
    FROM vote_post AS vp
    WHERE vp.user_id = $4
    GROUP BY vp.post_id
) AS user_votes ON posts.id = user_votes.post_id
WHERE
    posts.creator_id = $1
ORDER BY
    posts.created_at DESC
LIMIT
    $2
OFFSET
    $3
`

type GetPostsOfUserParams struct {
	CreatorID int32 `json:"creator_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
	UserID    int32 `json:"user_id"`
}

type GetPostsOfUserRow struct {
	ID                  int32       `json:"id"`
	Title               string      `json:"title"`
	Text                string      `json:"text"`
	Image               string      `json:"image"`
	Video               string      `json:"video"`
	Link                string      `json:"link"`
	SubredditID         int32       `json:"subreddit_id"`
	CreatorID           int32       `json:"creator_id"`
	CreatedAt           time.Time   `json:"created_at"`
	CreatorUsername     string      `json:"creator_username"`
	CreatorAvatar       string      `json:"creator_avatar"`
	CreatorName         string      `json:"creator_name"`
	SubredditName       string      `json:"subreddit_name"`
	SubredditAvatar     string      `json:"subreddit_avatar"`
	SubredditIsVerified bool        `json:"subreddit_is_verified"`
	SubredditTitle      string      `json:"subreddit_title"`
	RepliesCount        int64       `json:"replies_count"`
	UpVoteCount         int64       `json:"up_vote_count"`
	DownVoteCount       int64       `json:"down_vote_count"`
	Vote                interface{} `json:"vote"`
}

func (q *Queries) GetPostsOfUser(ctx context.Context, arg GetPostsOfUserParams) ([]GetPostsOfUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfUser,
		arg.CreatorID,
		arg.Limit,
		arg.Offset,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsOfUserRow
	for rows.Next() {
		var i GetPostsOfUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Text,
			&i.Image,
			&i.Video,
			&i.Link,
			&i.SubredditID,
			&i.CreatorID,
			&i.CreatedAt,
			&i.CreatorUsername,
			&i.CreatorAvatar,
			&i.CreatorName,
			&i.SubredditName,
			&i.SubredditAvatar,
			&i.SubredditIsVerified,
			&i.SubredditTitle,
			&i.RepliesCount,
			&i.UpVoteCount,
			&i.DownVoteCount,
			&i.Vote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubredditPosts = `-- name: GetSubredditPosts :many
SELECT
    posts.id,
    posts.title,
    posts.text,
    posts.image,
    posts.video,
    posts.link,
    posts.subreddit_id,
    posts.creator_id,
    posts.created_at,
    users.username AS creator_username,
    users.avatar AS creator_avatar,
    users.name AS creator_name,
    subreddit.name AS subreddit_name,
    subreddit.avatar AS subreddit_avatar,
    subreddit.is_verified AS subreddit_is_verified,
    subreddit.title AS subreddit_title,
    COALESCE(replies.replies_count, 0) AS replies_count,
    COALESCE(up_votes.up_vote_count, 0) AS up_vote_count,
    COALESCE(down_votes.down_vote_count, 0) AS down_vote_count,
    COALESCE(user_votes.vote, 0) AS vote
FROM
    posts
JOIN
    users ON posts.creator_id = users.id
JOIN
    subreddit ON posts.subreddit_id = subreddit.id
LEFT JOIN (
    SELECT post_id, COUNT(id) AS replies_count
    FROM replies
    GROUP BY post_id
) AS replies ON posts.id = replies.post_id
LEFT JOIN (
    SELECT post_id, COUNT(user_id) AS up_vote_count
    FROM vote_post
    WHERE down = FALSE
    GROUP BY post_id
) AS up_votes ON posts.id = up_votes.post_id
LEFT JOIN (
    SELECT post_id, COUNT(user_id) AS down_vote_count
    FROM vote_post
    WHERE down = TRUE
    GROUP BY post_id
) AS down_votes ON posts.id = down_votes.post_id
LEFT JOIN (
    SELECT post_id, MAX(CASE WHEN vp.user_id = $4 AND vp.down = FALSE THEN 1 WHEN vp.user_id = $4 AND vp.down = TRUE THEN -1 ELSE 0 END) AS vote
    FROM vote_post AS vp
    WHERE vp.user_id = $4
    GROUP BY vp.post_id
) AS user_votes ON posts.id = user_votes.post_id
WHERE
    posts.subreddit_id = $1
ORDER BY
    posts.created_at DESC
LIMIT
    $2
OFFSET
    $3
`

type GetSubredditPostsParams struct {
	SubredditID int32 `json:"subreddit_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
	UserID      int32 `json:"user_id"`
}

type GetSubredditPostsRow struct {
	ID                  int32       `json:"id"`
	Title               string      `json:"title"`
	Text                string      `json:"text"`
	Image               string      `json:"image"`
	Video               string      `json:"video"`
	Link                string      `json:"link"`
	SubredditID         int32       `json:"subreddit_id"`
	CreatorID           int32       `json:"creator_id"`
	CreatedAt           time.Time   `json:"created_at"`
	CreatorUsername     string      `json:"creator_username"`
	CreatorAvatar       string      `json:"creator_avatar"`
	CreatorName         string      `json:"creator_name"`
	SubredditName       string      `json:"subreddit_name"`
	SubredditAvatar     string      `json:"subreddit_avatar"`
	SubredditIsVerified bool        `json:"subreddit_is_verified"`
	SubredditTitle      string      `json:"subreddit_title"`
	RepliesCount        int64       `json:"replies_count"`
	UpVoteCount         int64       `json:"up_vote_count"`
	DownVoteCount       int64       `json:"down_vote_count"`
	Vote                interface{} `json:"vote"`
}

func (q *Queries) GetSubredditPosts(ctx context.Context, arg GetSubredditPostsParams) ([]GetSubredditPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubredditPosts,
		arg.SubredditID,
		arg.Limit,
		arg.Offset,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubredditPostsRow
	for rows.Next() {
		var i GetSubredditPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Text,
			&i.Image,
			&i.Video,
			&i.Link,
			&i.SubredditID,
			&i.CreatorID,
			&i.CreatedAt,
			&i.CreatorUsername,
			&i.CreatorAvatar,
			&i.CreatorName,
			&i.SubredditName,
			&i.SubredditAvatar,
			&i.SubredditIsVerified,
			&i.SubredditTitle,
			&i.RepliesCount,
			&i.UpVoteCount,
			&i.DownVoteCount,
			&i.Vote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrendingPostsPublic = `-- name: GetTrendingPostsPublic :many
SELECT
    posts.id,
    posts.title,
    posts.text,
    posts.image,
    posts.video,
    posts.link,
    posts.subreddit_id,
    posts.creator_id,
    posts.created_at,
    users.username AS creator_username,
    users.avatar AS creator_avatar,
    users.name AS creator_name,
    subreddit.name AS subreddit_name,
    subreddit.avatar AS subreddit_avatar,
    subreddit.is_verified AS subreddit_is_verified,
    subreddit.title AS subreddit_title,
    COALESCE(replies.replies_count, 0) AS replies_count,
    COALESCE(up_votes.up_vote_count, 0) AS up_vote_count,
    COALESCE(down_votes.down_vote_count, 0) AS down_vote_count,
    COALESCE(user_votes.vote, 0) AS vote
FROM
    posts
JOIN
    users ON posts.creator_id = users.id
JOIN
    subreddit ON posts.subreddit_id = subreddit.id
LEFT JOIN (
    SELECT post_id, COUNT(id) AS replies_count
    FROM replies
    GROUP BY post_id
) AS replies ON posts.id = replies.post_id
LEFT JOIN (
    SELECT post_id, COUNT(user_id) AS up_vote_count
    FROM vote_post
    WHERE down = FALSE
    GROUP BY post_id
) AS up_votes ON posts.id = up_votes.post_id
LEFT JOIN (
    SELECT post_id, COUNT(user_id) AS down_vote_count
    FROM vote_post
    WHERE down = TRUE
    GROUP BY post_id
) AS down_votes ON posts.id = down_votes.post_id
LEFT JOIN (
    SELECT post_id, MAX(CASE WHEN vp.user_id = $1 AND vp.down = FALSE THEN 1 WHEN vp.user_id = $1 AND vp.down = TRUE THEN -1 ELSE 0 END) AS vote
    FROM vote_post AS vp
    WHERE vp.user_id = $1
    GROUP BY vp.post_id
) AS user_votes ON posts.id = user_votes.post_id
WHERE
    posts.created_at >= current_date - interval '7 days'
ORDER BY
    (up_vote_count - down_vote_count) DESC
LIMIT
    10
`

type GetTrendingPostsPublicRow struct {
	ID                  int32       `json:"id"`
	Title               string      `json:"title"`
	Text                string      `json:"text"`
	Image               string      `json:"image"`
	Video               string      `json:"video"`
	Link                string      `json:"link"`
	SubredditID         int32       `json:"subreddit_id"`
	CreatorID           int32       `json:"creator_id"`
	CreatedAt           time.Time   `json:"created_at"`
	CreatorUsername     string      `json:"creator_username"`
	CreatorAvatar       string      `json:"creator_avatar"`
	CreatorName         string      `json:"creator_name"`
	SubredditName       string      `json:"subreddit_name"`
	SubredditAvatar     string      `json:"subreddit_avatar"`
	SubredditIsVerified bool        `json:"subreddit_is_verified"`
	SubredditTitle      string      `json:"subreddit_title"`
	RepliesCount        int64       `json:"replies_count"`
	UpVoteCount         int64       `json:"up_vote_count"`
	DownVoteCount       int64       `json:"down_vote_count"`
	Vote                interface{} `json:"vote"`
}

func (q *Queries) GetTrendingPostsPublic(ctx context.Context, userID int32) ([]GetTrendingPostsPublicRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrendingPostsPublic, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrendingPostsPublicRow
	for rows.Next() {
		var i GetTrendingPostsPublicRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Text,
			&i.Image,
			&i.Video,
			&i.Link,
			&i.SubredditID,
			&i.CreatorID,
			&i.CreatedAt,
			&i.CreatorUsername,
			&i.CreatorAvatar,
			&i.CreatorName,
			&i.SubredditName,
			&i.SubredditAvatar,
			&i.SubredditIsVerified,
			&i.SubredditTitle,
			&i.RepliesCount,
			&i.UpVoteCount,
			&i.DownVoteCount,
			&i.Vote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePostVote = `-- name: RemovePostVote :exec
DELETE FROM vote_post
WHERE vote_post.post_id = $1 AND vote_post.user_id = $2
`

type RemovePostVoteParams struct {
	PostID int32 `json:"post_id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) RemovePostVote(ctx context.Context, arg RemovePostVoteParams) error {
	_, err := q.db.ExecContext(ctx, removePostVote, arg.PostID, arg.UserID)
	return err
}

const votePost = `-- name: VotePost :exec
INSERT INTO vote_post (post_id, user_id, down)
VALUES ($1, $2, $3)
ON CONFLICT (post_id, user_id)
DO UPDATE SET down = $3
WHERE vote_post.post_id = $1 AND vote_post.user_id = $2
`

type VotePostParams struct {
	PostID int32 `json:"post_id"`
	UserID int32 `json:"user_id"`
	Down   bool  `json:"down"`
}

func (q *Queries) VotePost(ctx context.Context, arg VotePostParams) error {
	_, err := q.db.ExecContext(ctx, votePost, arg.PostID, arg.UserID, arg.Down)
	return err
}
