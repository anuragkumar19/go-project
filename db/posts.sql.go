// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: posts.sql

package database

import (
	"context"
	"time"
)

const createPost = `-- name: CreatePost :many
INSERT INTO posts (
    title, text, image, video, link, subreddit_id, creator_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id
`

type CreatePostParams struct {
	Title       string `json:"title"`
	Text        string `json:"text"`
	Image       string `json:"image"`
	Video       string `json:"video"`
	Link        string `json:"link"`
	SubredditID int32  `json:"subreddit_id"`
	CreatorID   int32  `json:"creator_id"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, createPost,
		arg.Title,
		arg.Text,
		arg.Image,
		arg.Video,
		arg.Link,
		arg.SubredditID,
		arg.CreatorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPostById = `-- name: FindPostById :many
SELECT id, creator_id, subreddit_id FROM posts
WHERE id = $1
`

type FindPostByIdRow struct {
	ID          int32 `json:"id"`
	CreatorID   int32 `json:"creator_id"`
	SubredditID int32 `json:"subreddit_id"`
}

func (q *Queries) FindPostById(ctx context.Context, id int32) ([]FindPostByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, findPostById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindPostByIdRow
	for rows.Next() {
		var i FindPostByIdRow
		if err := rows.Scan(&i.ID, &i.CreatorID, &i.SubredditID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByIDPublic = `-- name: GetPostByIDPublic :many
SELECT
    posts.id,
    posts.title,
    posts.text,
    posts.image,
    posts.video,
    posts.link,
    posts.subreddit_id,
    posts.creator_id,
    posts.created_at,
    users.username AS creator_username,
    users.avatar AS creator_avatar,
    users.name AS creator_name,
    subreddit.name AS subreddit_name,
    subreddit.avatar AS subreddit_avatar,
    subreddit.is_verified AS subreddit_is_verified,
    subreddit.title AS subreddit_title,
    count(replies.id) AS replies_count
FROM
    posts
JOIN
    users ON posts.creator_id = users.id
JOIN
    subreddit ON posts.subreddit_id = subreddit.id
JOIN
    replies ON posts.id = replies.post_id
WHERE
    posts.id = $1
`

type GetPostByIDPublicRow struct {
	ID                  int32     `json:"id"`
	Title               string    `json:"title"`
	Text                string    `json:"text"`
	Image               string    `json:"image"`
	Video               string    `json:"video"`
	Link                string    `json:"link"`
	SubredditID         int32     `json:"subreddit_id"`
	CreatorID           int32     `json:"creator_id"`
	CreatedAt           time.Time `json:"created_at"`
	CreatorUsername     string    `json:"creator_username"`
	CreatorAvatar       string    `json:"creator_avatar"`
	CreatorName         string    `json:"creator_name"`
	SubredditName       string    `json:"subreddit_name"`
	SubredditAvatar     string    `json:"subreddit_avatar"`
	SubredditIsVerified bool      `json:"subreddit_is_verified"`
	SubredditTitle      string    `json:"subreddit_title"`
	RepliesCount        int64     `json:"replies_count"`
}

func (q *Queries) GetPostByIDPublic(ctx context.Context, id int32) ([]GetPostByIDPublicRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostByIDPublic, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostByIDPublicRow
	for rows.Next() {
		var i GetPostByIDPublicRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Text,
			&i.Image,
			&i.Video,
			&i.Link,
			&i.SubredditID,
			&i.CreatorID,
			&i.CreatedAt,
			&i.CreatorUsername,
			&i.CreatorAvatar,
			&i.CreatorName,
			&i.SubredditName,
			&i.SubredditAvatar,
			&i.SubredditIsVerified,
			&i.SubredditTitle,
			&i.RepliesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostVote = `-- name: GetPostVote :many
SELECT post_id, user_id, down FROM vote_post
WHERE post_id = $1 AND user_id = $2
`

type GetPostVoteParams struct {
	PostID int32 `json:"post_id"`
	UserID int32 `json:"user_id"`
}

type GetPostVoteRow struct {
	PostID int32 `json:"post_id"`
	UserID int32 `json:"user_id"`
	Down   bool  `json:"down"`
}

func (q *Queries) GetPostVote(ctx context.Context, arg GetPostVoteParams) ([]GetPostVoteRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostVote, arg.PostID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostVoteRow
	for rows.Next() {
		var i GetPostVoteRow
		if err := rows.Scan(&i.PostID, &i.UserID, &i.Down); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePostVote = `-- name: RemovePostVote :exec
DELETE FROM vote_post
WHERE vote_post.post_id = $1 AND vote_post.user_id = $2
`

type RemovePostVoteParams struct {
	PostID int32 `json:"post_id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) RemovePostVote(ctx context.Context, arg RemovePostVoteParams) error {
	_, err := q.db.ExecContext(ctx, removePostVote, arg.PostID, arg.UserID)
	return err
}

const votePost = `-- name: VotePost :exec
INSERT INTO vote_post (post_id, user_id, down)
VALUES ($1, $2, $3)
ON CONFLICT (post_id, user_id)
DO UPDATE SET down = $3
WHERE vote_post.post_id = $1 AND vote_post.user_id = $2
`

type VotePostParams struct {
	PostID int32 `json:"post_id"`
	UserID int32 `json:"user_id"`
	Down   bool  `json:"down"`
}

func (q *Queries) VotePost(ctx context.Context, arg VotePostParams) error {
	_, err := q.db.ExecContext(ctx, votePost, arg.PostID, arg.UserID, arg.Down)
	return err
}
